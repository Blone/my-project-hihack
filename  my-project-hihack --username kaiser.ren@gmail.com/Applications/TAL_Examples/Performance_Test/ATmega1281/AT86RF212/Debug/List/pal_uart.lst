###############################################################################
#                                                                             #
# IAR C/C++ Compiler V6.11.1.50453 for Atmel AVR        24/Nov/2012  12:22:58 #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\HiJack\PAL\AVR\Generic\Src\pal_uart.c                 #
#    Command line =  D:\HiJack\PAL\AVR\Generic\Src\pal_uart.c --cpu=m1281     #
#                    -ms -o D:\HiJack\Applications\TAL_Examples\Performance_T #
#                    est\ATmega1281\AT86RF212\Debug\Obj\ -D DEBUG=0 -D FFD    #
#                    -D HIGH_DATA_RATE_SUPPORT -D ENABLE_TFA -D SIO_HUB -D    #
#                    UART1 -D TAL_TYPE=AT86RF212 -D PAL_TYPE=ATMEGA1281 -D    #
#                    PAL_GENERIC_TYPE=AVR -D BOARD_TYPE=ATZB_900_MN2 -D       #
#                    HIGHEST_STACK_LAYER=PAL -lCN                             #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\AT86RF212\Debug\List\ --remarks -y               #
#                    --initializers_in_flash --no_cse --no_inline             #
#                    --no_code_motion --no_cross_call --no_clustering         #
#                    --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I         #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\Inc\ -I D:\HiJack\Applications\TAL_Examples\P #
#                    erformance_Test\ATmega1281\ -I                           #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\Helper_Files\SIO_Support\Inc\ -I        #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\Include\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\TAL\Inc\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\TAL\AT86RF212\Inc\ -I                #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\TFA\Inc\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\Inc\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\Generic\Inc\ -I              #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\ATMEGA1281\Inc\ -I           #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\ATMEGA1281\Boards\ -I        #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\ATMEGA1281\Boards\ATZB_900_M #
#                    N2\ -I D:\HiJack\Applications\TAL_Examples\Performance_T #
#                    est\ATmega1281\..\..\..\..\Resources\Buffer_Management\I #
#                    nc\ -I D:\HiJack\Applications\TAL_Examples\Performance_T #
#                    est\ATmega1281\..\..\..\..\Resources\Queue_Management\In #
#                    c\ --eeprom_size 4096 --dlib --dlib_config "D:\Program   #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On                #
#    List file    =  D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\AT86RF212\Debug\List\pal_uart.lst                #
#    Object file  =  D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\AT86RF212\Debug\Obj\pal_uart.r90                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\HiJack\PAL\AVR\Generic\Src\pal_uart.c
      1          /**
      2           * @file pal_uart.c
      3           *
      4           * @brief UART related functions for AVR 8-Bit MCUs
      5           *
      6           * This file implements UART related transmission and reception functions
      7           * functions for AVR 8-Bit MCUs.
      8           *
      9           * $Id: pal_uart.c 19263 2009-11-23 08:37:32Z sschneid $
     10           *
     11           * @author    Atmel Corporation: http://www.atmel.com
     12           * @author    Support email: avr@atmel.com
     13           */
     14          /*
     15           * Copyright (c) 2009, Atmel Corporation All rights reserved.
     16           *
     17           * Licensed under Atmel's Limited License Agreement --> EULA.txt
     18           */
     19          
     20          /* === Includes ============================================================= */
     21          
     22          #if ((defined UART0) || (defined UART1))
     23          #include <stdint.h>
     24          #include "pal_uart.h"

   \                                 In  segment ABSOLUTE, at 0xce
   \   union <unnamed> volatile __io _A_UDR1
   \                     _A_UDR1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xcc
   \   union <unnamed> volatile __io _A_UBRR1
   \                     _A_UBRR1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xca
   \   union <unnamed> volatile __io _A_UCSR1C
   \                     _A_UCSR1C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc9
   \   union <unnamed> volatile __io _A_UCSR1B
   \                     _A_UCSR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc8
   \   union <unnamed> volatile __io _A_UCSR1A
   \                     _A_UCSR1A:
   \   00000000                      DS8 1
     25          
     26          /* === Macros =============================================================== */
     27          
     28          
     29          /* === Globals ============================================================== */
     30          
     31          #if (defined UART0)
     32          uart_communication_buffer_t uart_0_buffer;
     33          #endif
     34          
     35          #if (defined UART1)

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     36          uart_communication_buffer_t uart_1_buffer;
   \                     uart_1_buffer:
   \   00000000                      DS8 26
     37          #endif
     38          
     39          /* === Prototypes =========================================================== */
     40          
     41          
     42          /* === Implementation ======================================================= */
     43          
     44          #ifdef UART0
     45          /**
     46           * @brief Initializes UART 0
     47           *
     48           * This function initializes the UART channel 0.
     49           *
     50           * @param baud_rate Actual UART baud rate
     51           */
     52          void sio_uart_0_init(uint32_t baud_rate)
     53          {
     54              /* Calculate corresponding value for baud rateregister. */
     55              uint16_t baud_rate_reg = UART_BAUD(baud_rate);
     56          
     57              /*
     58               * Microcontroller's USART register is updated to
     59               * run at the given baud rate.
     60               */
     61              UBRR0H = (baud_rate_reg >> 8) & 0xFF;
     62              UBRR0L = (uint8_t)baud_rate_reg;
     63          
     64              /* Faster async mode (UART clock divider = 8, instead of 16) */
     65              UCSR0A = (1 << U2X0);
     66          
     67              /*
     68               * Receiver and transmitter are enabled.
     69               * Receive and transmit interrrupt are enabled.
     70               */
     71              UCSR0B = (1 << RXEN0) | (1 << TXEN0) | \
     72                       (1 << RXCIE0) | (1 << TXCIE0);
     73          
     74              /*
     75               * Boards specific initialization.
     76               */
     77              UART_0_INIT_NON_GENERIC();
     78          }
     79          #endif  /* UART0 */
     80          
     81          
     82          
     83          #ifdef UART1
     84          /**
     85           * @brief Initializes UART 1
     86           *
     87           * This function initializes the UART channel 1.
     88           *
     89           * @param baud_rate Actual UART baud rate
     90           */

   \                                 In  segment CODE, align 2, keep-with-next
     91          void sio_uart_1_init(uint32_t baud_rate)
   \                     sio_uart_1_init:
     92          {
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   01D9               MOVW    R27:R26, R19:R18
     93              /* Calculate corresponding value for baud rateregister. */
     94              uint16_t baud_rate_reg = UART_BAUD(baud_rate);
   \   00000008   E044               LDI     R20, 4
   \   0000000A   E050               LDI     R21, 0
   \   0000000C   E060               LDI     R22, 0
   \   0000000E   E070               LDI     R23, 0
   \   00000010   018C               MOVW    R17:R16, R25:R24
   \   00000012   019D               MOVW    R19:R18, R27:R26
   \   00000014   ........           CALL    ?L_EC_MUL_L03
   \   00000018   5000               SUBI    R16, 0
   \   0000001A   4F17               SBCI    R17, 247
   \   0000001C   4C22               SBCI    R18, 194
   \   0000001E   4F3F               SBCI    R19, 255
   \   00000020   0128               MOVW    R5:R4, R17:R16
   \   00000022   0139               MOVW    R7:R6, R19:R18
   \   00000024   E048               LDI     R20, 8
   \   00000026   E050               LDI     R21, 0
   \   00000028   E060               LDI     R22, 0
   \   0000002A   E070               LDI     R23, 0
   \   0000002C   018C               MOVW    R17:R16, R25:R24
   \   0000002E   019D               MOVW    R19:R18, R27:R26
   \   00000030   ........           CALL    ?L_EC_MUL_L03
   \   00000034   01A8               MOVW    R21:R20, R17:R16
   \   00000036   01B9               MOVW    R23:R22, R19:R18
   \   00000038   0182               MOVW    R17:R16, R5:R4
   \   0000003A   0193               MOVW    R19:R18, R7:R6
   \   0000003C   ........           CALL    ?UL_DIVMOD_L03
   \   00000040   01F8               MOVW    R31:R30, R17:R16
   \   00000042   9731               SBIW    R31:R30, 1
     95          
     96              /*
     97               * Microcontroller's USART register is updated to
     98               * run at the given baud rate.
     99               */
    100              UBRR1H = (baud_rate_reg >> 8) & 0xFF;
   \   00000044   018F               MOVW    R17:R16, R31:R30
   \   00000046   2F01               MOV     R16, R17
   \   00000048   E010               LDI     R17, 0
   \   0000004A   930000CD           STS     205, R16
    101              UBRR1L = (uint8_t)baud_rate_reg;
   \   0000004E   2F0E               MOV     R16, R30
   \   00000050   9300....           STS     _A_UBRR1, R16
    102          
    103              /* Faster async mode (UART clock divider = 8, instead of 16) */
    104              UCSR1A = (1 << U2X1);
   \   00000054   E002               LDI     R16, 2
   \   00000056   9300....           STS     _A_UCSR1A, R16
    105          
    106              /*
    107               * Receiver and transmitter are enabled.
    108               * Receive and transmit interrrupt are enabled.
    109               */
    110              UCSR1B = (1 << RXEN1) | (1 << TXEN1) | \
    111                       (1 << RXCIE1) | (1 << TXCIE1);
   \   0000005A   ED08               LDI     R16, 216
   \   0000005C   9300....           STS     _A_UCSR1B, R16
    112          
    113              /*
    114               * Boards specific initialization.
    115               */
    116              UART_1_INIT_NON_GENERIC();
   \   00000060   E006               LDI     R16, 6
   \   00000062   9300....           STS     _A_UCSR1C, R16
    117          }
   \   00000066   E0E8               LDI     R30, 8
   \   00000068   ........           JMP     ?EPILOGUE_B8_L09
   \   0000006C                      REQUIRE _A_UBRR1
   \   0000006C                      REQUIRE _A_UCSR1A
   \   0000006C                      REQUIRE _A_UCSR1B
   \   0000006C                      REQUIRE _A_UCSR1C
    118          #endif  /* UART1 */
    119          
    120          
    121          
    122          #ifdef UART0
    123          /**
    124           * @brief Transmit data via UART 0
    125           *
    126           * This function transmits data via UART channel 0.
    127           *
    128           * @param data Pointer to the buffer where the data to be transmitted is present
    129           * @param length Number of bytes to be transmitted
    130           *
    131           * @return Number of bytes actually transmitted
    132           */
    133          uint8_t sio_uart_0_tx(uint8_t *data, uint8_t length)
    134          {
    135              uint8_t bytes_to_be_written;
    136              uint8_t head;
    137              uint8_t tail;
    138              uint8_t size;
    139              uint8_t back;
    140          
    141              /* The transmit interrupt is disabled. */
    142              DISABLE_UART_0_TX_INT();
    143          
    144              /*
    145               * Calculate available buffer space
    146               */
    147              head = uart_0_buffer.tx_buf_head;
    148              tail = uart_0_buffer.tx_buf_tail;
    149          
    150              if (tail >= head)
    151              {
    152                  size = (UART_MAX_TX_BUF_LENGTH - 1) - (tail - head);
    153              }
    154              else
    155              {
    156                  size = (head - 1) - tail;
    157              }
    158          
    159              if (size < length)
    160              {
    161                  /* Not enough buffer space available. Use the remaining size. */
    162                  bytes_to_be_written = size;
    163              }
    164              else
    165              {
    166                  bytes_to_be_written = length;
    167              }
    168          
    169              /* Remember the number of bytes transmitted. */
    170              back = bytes_to_be_written;
    171          
    172              /* The data is copied to the transmit buffer. */
    173              while (bytes_to_be_written > 0)
    174              {
    175                  uart_0_buffer.tx_buf[uart_0_buffer.tx_buf_tail] = *data;
    176          
    177                  if ((UART_MAX_TX_BUF_LENGTH - 1) == uart_0_buffer.tx_buf_tail)
    178                  {
    179                      /* Reached the end of buffer, revert back to beginning of buffer. */
    180                      uart_0_buffer.tx_buf_tail = 0;
    181                  }
    182                  else
    183                  {
    184                      /*
    185                       * Increment the index to point the next character to be
    186                       * inserted.
    187                       */
    188                      uart_0_buffer.tx_buf_tail++;
    189                  }
    190          
    191                  bytes_to_be_written--;
    192                  data++;
    193              }
    194          
    195              /*
    196               * Check whether there is a transmission ongoing. Otherwise write
    197               * data into the UART data register. Transmission of subsequent
    198               * bytes / data will be taken care in the ISR.
    199               */
    200              if (uart_0_buffer.tx_count == 0)
    201              {
    202                  UDR0 = uart_0_buffer.tx_buf[head];
    203                  uart_0_buffer.tx_count = 1;
    204              }
    205          
    206              /* The transmit interrupt is enabled. */
    207              ENABLE_UART_0_TX_INT();
    208          
    209              return back;
    210          }
    211          #endif  /* UART0 */
    212          
    213          
    214          
    215          #ifdef UART1
    216          /**
    217           * @brief Transmit data via UART 1
    218           *
    219           * This function transmits data via UART channel 1.
    220           *
    221           * @param data Pointer to the buffer where the data to be transmitted is present
    222           * @param length Number of bytes to be transmitted
    223           *
    224           * @return Number of bytes actually transmitted
    225           */

   \                                 In  segment CODE, align 2, keep-with-next
    226          uint8_t sio_uart_1_tx(uint8_t *data, uint8_t length)
   \                     sio_uart_1_tx:
    227          {
   \   00000000   2E19               MOV     R1, R25
   \   00000002   2E28               MOV     R2, R24
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   2F42               MOV     R20, R18
    228              uint8_t bytes_to_be_written;
    229              uint8_t head;
    230              uint8_t tail;
    231              uint8_t size;
    232              uint8_t back;
    233          
    234              /* The transmit interrupt is disabled. */
    235              DISABLE_UART_1_TX_INT();
   \   00000008   913000C9           LDS     R19, 201
   \   0000000C   7B3F               ANDI    R19, 0xBF
   \   0000000E   933000C9           STS     201, R19
    236          
    237              /*
    238               * Calculate available buffer space
    239               */
    240              head = uart_1_buffer.tx_buf_head;
   \   00000012   9130....           LDS     R19, (uart_1_buffer + 20)
   \   00000016   2F23               MOV     R18, R19
    241              tail = uart_1_buffer.tx_buf_tail;
   \   00000018   9130....           LDS     R19, (uart_1_buffer + 21)
   \   0000001C   2F53               MOV     R21, R19
    242          
    243              if (tail >= head)
   \   0000001E   1752               CP      R21, R18
   \   00000020   F028               BRCS    ??sio_uart_1_tx_0
    244              {
    245                  size = (UART_MAX_TX_BUF_LENGTH - 1) - (tail - head);
   \   00000022   E039               LDI     R19, 9
   \   00000024   1B35               SUB     R19, R21
   \   00000026   0F32               ADD     R19, R18
   \   00000028   2E03               MOV     R0, R19
   \   0000002A   C004               RJMP    ??sio_uart_1_tx_1
    246              }
    247              else
    248              {
    249                  size = (head - 1) - tail;
   \                     ??sio_uart_1_tx_0:
   \   0000002C   2F32               MOV     R19, R18
   \   0000002E   953A               DEC     R19
   \   00000030   1B35               SUB     R19, R21
   \   00000032   2E03               MOV     R0, R19
    250              }
    251          
    252              if (size < length)
   \                     ??sio_uart_1_tx_1:
   \   00000034   1604               CP      R0, R20
   \   00000036   F410               BRCC    ??sio_uart_1_tx_2
    253              {
    254                  /* Not enough buffer space available. Use the remaining size. */
    255                  bytes_to_be_written = size;
   \   00000038   2D10               MOV     R17, R0
   \   0000003A   C001               RJMP    ??sio_uart_1_tx_3
    256              }
    257              else
    258              {
    259                  bytes_to_be_written = length;
   \                     ??sio_uart_1_tx_2:
   \   0000003C   2F14               MOV     R17, R20
    260              }
    261          
    262              /* Remember the number of bytes transmitted. */
    263              back = bytes_to_be_written;
   \                     ??sio_uart_1_tx_3:
   \   0000003E   2F01               MOV     R16, R17
    264          
    265              /* The data is copied to the transmit buffer. */
    266              while (bytes_to_be_written > 0)
   \                     ??sio_uart_1_tx_4:
   \   00000040   3011               CPI     R17, 1
   \   00000042   F0C8               BRCS    ??sio_uart_1_tx_5
    267              {
    268                  uart_1_buffer.tx_buf[uart_1_buffer.tx_buf_tail] = *data;
   \   00000044   01FC               MOVW    R31:R30, R25:R24
   \   00000046   8130               LD      R19, Z
   \   00000048   9160....           LDS     R22, (uart_1_buffer + 21)
   \   0000004C   E070               LDI     R23, 0
   \   0000004E   01FB               MOVW    R31:R30, R23:R22
   \   00000050   ....               SUBI    R30, LOW((-(uart_1_buffer) & 0xFFFF))
   \   00000052   ....               SBCI    R31, (-(uart_1_buffer) & 0xFFFF) >> 8
   \   00000054   8330               ST      Z, R19
    269          
    270                  if ((UART_MAX_TX_BUF_LENGTH - 1) == uart_1_buffer.tx_buf_tail)
   \   00000056   9130....           LDS     R19, (uart_1_buffer + 21)
   \   0000005A   3039               CPI     R19, 9
   \   0000005C   F421               BRNE    ??sio_uart_1_tx_6
    271                  {
    272                      /* Reached the end of buffer, revert back to beginning of buffer. */
    273                      uart_1_buffer.tx_buf_tail = 0;
   \   0000005E   E030               LDI     R19, 0
   \   00000060   9330....           STS     (uart_1_buffer + 21), R19
   \   00000064   C005               RJMP    ??sio_uart_1_tx_7
    274                  }
    275                  else
    276                  {
    277                      /*
    278                       * Increment the index to point the next character to be
    279                       * inserted.
    280                       */
    281                      uart_1_buffer.tx_buf_tail++;
   \                     ??sio_uart_1_tx_6:
   \   00000066   9130....           LDS     R19, (uart_1_buffer + 21)
   \   0000006A   9533               INC     R19
   \   0000006C   9330....           STS     (uart_1_buffer + 21), R19
    282                  }
    283          
    284                  bytes_to_be_written--;
   \                     ??sio_uart_1_tx_7:
   \   00000070   951A               DEC     R17
    285                  data++;
   \   00000072   9601               ADIW    R25:R24, 1
   \   00000074   CFE5               RJMP    ??sio_uart_1_tx_4
    286              }
    287          
    288              /*
    289               * Check whether there is a transmission ongoing. Otherwise write
    290               * data into the UART data register. Transmission of subsequent
    291               * bytes / data will be taken care in the ISR.
    292               */
    293              if (uart_1_buffer.tx_count == 0)
   \                     ??sio_uart_1_tx_5:
   \   00000076   9130....           LDS     R19, (uart_1_buffer + 24)
   \   0000007A   2333               TST     R19
   \   0000007C   F451               BRNE    ??sio_uart_1_tx_8
    294              {
    295                  UDR1 = uart_1_buffer.tx_buf[head];
   \   0000007E   E030               LDI     R19, 0
   \   00000080   01F9               MOVW    R31:R30, R19:R18
   \   00000082   ....               SUBI    R30, LOW((-(uart_1_buffer) & 0xFFFF))
   \   00000084   ....               SBCI    R31, (-(uart_1_buffer) & 0xFFFF) >> 8
   \   00000086   8130               LD      R19, Z
   \   00000088   9330....           STS     _A_UDR1, R19
    296                  uart_1_buffer.tx_count = 1;
   \   0000008C   E031               LDI     R19, 1
   \   0000008E   9330....           STS     (uart_1_buffer + 24), R19
    297              }
    298          
    299              /* The transmit interrupt is enabled. */
    300              ENABLE_UART_1_TX_INT();
   \                     ??sio_uart_1_tx_8:
   \   00000092   913000C9           LDS     R19, 201
   \   00000096   6430               ORI     R19, 0x40
   \   00000098   933000C9           STS     201, R19
    301          
    302              return back;
   \   0000009C   2D82               MOV     R24, R2
   \   0000009E   2D91               MOV     R25, R1
   \   000000A0   9508               RET
   \   000000A2                      REQUIRE _A_UCSR1B
   \   000000A2                      REQUIRE _A_UDR1
    303          }
    304          #endif  /* UART1 */
    305          
    306          
    307          
    308          #ifdef UART0
    309          /**
    310           * @brief Receives data from UART 0
    311           *
    312           * This function receives data from UART channel 0.
    313           *
    314           * @param data pointer to the buffer where the received data is to be stored
    315           * @param max_length maximum length of data to be received
    316           *
    317           * @return actual number of bytes received
    318           */
    319          uint8_t sio_uart_0_rx(uint8_t *data, uint8_t max_length)
    320          {
    321              uint8_t data_received = 0;
    322          
    323              if (uart_0_buffer.rx_count == 0)
    324              {
    325                  /* UART receive buffer is empty. */
    326                  return 0;
    327              }
    328          
    329              /* The receive interrupt is disabled. */
    330              DISABLE_UART_0_RX_INT();
    331          
    332              if (UART_MAX_RX_BUF_LENGTH <= uart_0_buffer.rx_count)
    333              {
    334                  /*
    335                   * Bytes between head and tail are overwritten by new data.
    336                   * The oldest data in buffer is the one to which the tail is
    337                   * pointing. So reading operation should start from the tail.
    338                   */
    339                  uart_0_buffer.rx_buf_head = uart_0_buffer.rx_buf_tail;
    340          
    341                  /*
    342                   * This is a buffer overflow case. But still only bytes equivalent to
    343                   * full buffer size are useful.
    344                   */
    345                  uart_0_buffer.rx_count = UART_MAX_RX_BUF_LENGTH;
    346          
    347                  /* Bytes received is more than or equal to buffer. */
    348                  if (UART_MAX_RX_BUF_LENGTH <= max_length)
    349                  {
    350                      /*
    351                       * Requested receive length (max_length) is more than the
    352                       * max size of receive buffer, but at max the full
    353                       * buffer can be read.
    354                       */
    355                      max_length = UART_MAX_RX_BUF_LENGTH;
    356                  }
    357              }
    358              else
    359              {
    360                  /* Bytes received is less than receive buffer maximum length. */
    361                  if (max_length > uart_0_buffer.rx_count)
    362                  {
    363                      /*
    364                       * Requested receive length (max_length) is more than the data
    365                       * present in receive buffer. Hence only the number of bytes
    366                       * present in receive buffer are read.
    367                       */
    368                      max_length = uart_0_buffer.rx_count;
    369                  }
    370              }
    371          
    372              data_received = max_length;
    373          
    374              while (max_length > 0)
    375              {
    376                  /* Start to copy from head. */
    377                  *data = uart_0_buffer.rx_buf[uart_0_buffer.rx_buf_head];
    378                  uart_0_buffer.rx_buf_head++;
    379                  uart_0_buffer.rx_count--;
    380                  data++;
    381                  max_length--;
    382                  if ((UART_MAX_RX_BUF_LENGTH) == uart_0_buffer.rx_buf_head)
    383                  {
    384                      uart_0_buffer.rx_buf_head = 0;
    385                  }
    386              }
    387          
    388              /* The receive interrupt is enabled back. */
    389              ENABLE_UART_0_RX_INT();
    390          
    391              return data_received;
    392          }
    393          #endif  /* UART0 */
    394          
    395          
    396          
    397          #ifdef UART1
    398          /**
    399           * @brief Receives data from UART 1
    400           *
    401           * This function receives data from UART channel 1.
    402           *
    403           * @param data pointer to the buffer where the received data is to be stored
    404           * @param max_length maximum length of data to be received
    405           *
    406           * @return actual number of bytes received
    407           */

   \                                 In  segment CODE, align 2, keep-with-next
    408          uint8_t sio_uart_1_rx(uint8_t *data, uint8_t max_length)
   \                     sio_uart_1_rx:
    409          {
   \   00000000   01AC               MOVW    R21:R20, R25:R24
   \   00000002   01C8               MOVW    R25:R24, R17:R16
    410              uint8_t data_received = 0;
   \   00000004   E030               LDI     R19, 0
    411          
    412              if (uart_1_buffer.rx_count == 0)
   \   00000006   9100....           LDS     R16, (uart_1_buffer + 25)
   \   0000000A   2300               TST     R16
   \   0000000C   F411               BRNE    ??sio_uart_1_rx_0
    413              {
    414                  /* UART receive buffer is empty. */
    415                  return 0;
   \   0000000E   E000               LDI     R16, 0
   \   00000010   C041               RJMP    ??sio_uart_1_rx_1
    416              }
    417          
    418              /* The receive interrupt is disabled. */
    419              DISABLE_UART_1_RX_INT();
   \                     ??sio_uart_1_rx_0:
   \   00000012   910000C9           LDS     R16, 201
   \   00000016   770F               ANDI    R16, 0x7F
   \   00000018   930000C9           STS     201, R16
    420          
    421              if (UART_MAX_RX_BUF_LENGTH <= uart_1_buffer.rx_count)
   \   0000001C   9100....           LDS     R16, (uart_1_buffer + 25)
   \   00000020   300A               CPI     R16, 10
   \   00000022   F058               BRCS    ??sio_uart_1_rx_2
    422              {
    423                  /*
    424                   * Bytes between head and tail are overwritten by new data.
    425                   * The oldest data in buffer is the one to which the tail is
    426                   * pointing. So reading operation should start from the tail.
    427                   */
    428                  uart_1_buffer.rx_buf_head = uart_1_buffer.rx_buf_tail;
   \   00000024   9100....           LDS     R16, (uart_1_buffer + 23)
   \   00000028   9300....           STS     (uart_1_buffer + 22), R16
    429          
    430                  /*
    431                   * This is a buffer overflow case. But still only bytes equivalent to
    432                   * full buffer size are useful.
    433                   */
    434                  uart_1_buffer.rx_count = UART_MAX_RX_BUF_LENGTH;
   \   0000002C   E00A               LDI     R16, 10
   \   0000002E   9300....           STS     (uart_1_buffer + 25), R16
    435          
    436                  /* Bytes received is more than or equal to buffer. */
    437                  if (UART_MAX_RX_BUF_LENGTH <= max_length)
   \   00000032   302A               CPI     R18, 10
   \   00000034   F048               BRCS    ??sio_uart_1_rx_3
    438                  {
    439                      /*
    440                       * Requested receive length (max_length) is more than the
    441                       * max size of receive buffer, but at max the full
    442                       * buffer can be read.
    443                       */
    444                      max_length = UART_MAX_RX_BUF_LENGTH;
   \   00000036   E02A               LDI     R18, 10
   \   00000038   C007               RJMP    ??sio_uart_1_rx_3
    445                  }
    446              }
    447              else
    448              {
    449                  /* Bytes received is less than receive buffer maximum length. */
    450                  if (max_length > uart_1_buffer.rx_count)
   \                     ??sio_uart_1_rx_2:
   \   0000003A   9100....           LDS     R16, (uart_1_buffer + 25)
   \   0000003E   1702               CP      R16, R18
   \   00000040   F418               BRCC    ??sio_uart_1_rx_3
    451                  {
    452                      /*
    453                       * Requested receive length (max_length) is more than the data
    454                       * present in receive buffer. Hence only the number of bytes
    455                       * present in receive buffer are read.
    456                       */
    457                      max_length = uart_1_buffer.rx_count;
   \   00000042   9100....           LDS     R16, (uart_1_buffer + 25)
   \   00000046   2F20               MOV     R18, R16
    458                  }
    459              }
    460          
    461              data_received = max_length;
   \                     ??sio_uart_1_rx_3:
   \   00000048   2F32               MOV     R19, R18
    462          
    463              while (max_length > 0)
   \                     ??sio_uart_1_rx_4:
   \   0000004A   3021               CPI     R18, 1
   \   0000004C   F0E8               BRCS    ??sio_uart_1_rx_5
    464              {
    465                  /* Start to copy from head. */
    466                  *data = uart_1_buffer.rx_buf[uart_1_buffer.rx_buf_head];
   \   0000004E   9100....           LDS     R16, (uart_1_buffer + 22)
   \   00000052   E010               LDI     R17, 0
   \   00000054   01F8               MOVW    R31:R30, R17:R16
   \   00000056   ....               SUBI    R30, LOW((-(uart_1_buffer) & 0xFFFF))
   \   00000058   ....               SBCI    R31, (-(uart_1_buffer) & 0xFFFF) >> 8
   \   0000005A   8502               LDD     R16, Z+10
   \   0000005C   01FC               MOVW    R31:R30, R25:R24
   \   0000005E   8300               ST      Z, R16
    467                  uart_1_buffer.rx_buf_head++;
   \   00000060   9100....           LDS     R16, (uart_1_buffer + 22)
   \   00000064   9503               INC     R16
   \   00000066   9300....           STS     (uart_1_buffer + 22), R16
    468                  uart_1_buffer.rx_count--;
   \   0000006A   9100....           LDS     R16, (uart_1_buffer + 25)
   \   0000006E   950A               DEC     R16
   \   00000070   9300....           STS     (uart_1_buffer + 25), R16
    469                  data++;
   \   00000074   9601               ADIW    R25:R24, 1
    470                  max_length--;
   \   00000076   952A               DEC     R18
    471                  if ((UART_MAX_RX_BUF_LENGTH) == uart_1_buffer.rx_buf_head)
   \   00000078   9100....           LDS     R16, (uart_1_buffer + 22)
   \   0000007C   300A               CPI     R16, 10
   \   0000007E   F729               BRNE    ??sio_uart_1_rx_4
    472                  {
    473                      uart_1_buffer.rx_buf_head = 0;
   \   00000080   E000               LDI     R16, 0
   \   00000082   9300....           STS     (uart_1_buffer + 22), R16
   \   00000086   CFE1               RJMP    ??sio_uart_1_rx_4
    474                  }
    475              }
    476          
    477              /* The receive interrupt is enabled back. */
    478              ENABLE_UART_1_RX_INT();
   \                     ??sio_uart_1_rx_5:
   \   00000088   910000C9           LDS     R16, 201
   \   0000008C   6800               ORI     R16, 0x80
   \   0000008E   930000C9           STS     201, R16
    479          
    480              return data_received;
   \   00000092   2F03               MOV     R16, R19
   \                     ??sio_uart_1_rx_1:
   \   00000094   01CA               MOVW    R25:R24, R21:R20
   \   00000096   9508               RET
   \   00000098                      REQUIRE _A_UCSR1B
    481          }
    482          #endif  /* UART1 */
    483          
    484          
    485          
    486          #ifdef UART0
    487          /**
    488           * @brief ISR for UART 0 receive interrupt
    489           *
    490           * This service routine is executed when a byte is received successfully on
    491           * UART channel 0.
    492           */
    493          ISR(USART0_RX_vect)
    494          {
    495              uint8_t tail = uart_0_buffer.rx_buf_tail;
    496          
    497              /* Count of bytes received through UART 0 channel is incremented. */
    498              uart_0_buffer.rx_count++;
    499          
    500              uart_0_buffer.rx_buf[tail] = UDR0;
    501          
    502              if ((UART_MAX_RX_BUF_LENGTH - 1) == uart_0_buffer.rx_buf_tail)
    503              {
    504                  /* Revert back to beginning of buffer after reaching end of buffer. */
    505                  uart_0_buffer.rx_buf_tail = 0;
    506              }
    507              else
    508              {
    509                  uart_0_buffer.rx_buf_tail++;
    510              }
    511          }
    512          
    513          
    514          
    515          /**
    516           * @brief ISR for UART 0 transmit interrupt
    517           *
    518           * This service routine is executed when a byte is transmitted successfully on
    519           * UART channel 0.
    520           */
    521          ISR(USART0_TX_vect)
    522          {
    523              if ((UART_MAX_TX_BUF_LENGTH - 1) == uart_0_buffer.tx_buf_head)
    524              {
    525                  /* Reached the end of buffer, revert back to beginning of buffer. */
    526                  uart_0_buffer.tx_buf_head = 0;
    527              }
    528              else
    529              {
    530                  /*
    531                   * Increment the index to point the next character to be
    532                   * transmitted.
    533                   */
    534                  uart_0_buffer.tx_buf_head++;
    535              }
    536          
    537              if (uart_0_buffer.tx_buf_head != uart_0_buffer.tx_buf_tail)
    538              {
    539                  UDR0 = uart_0_buffer.tx_buf[uart_0_buffer.tx_buf_head];
    540              }
    541              else
    542              {
    543                  /* No more data for transmission */
    544                  uart_0_buffer.tx_count = 0;
    545              }
    546          }
    547          #endif  /* UART0 */
    548          
    549          
    550          
    551          #ifdef UART1
    552          /**
    553           * @brief ISR for UART 1 receive interrupt
    554           *
    555           * This service routine is executed when a byte is received successfully on
    556           * UART channel 1.
    557           */

   \                                 In  segment CODE, align 2, keep-with-next
    558          ISR(USART1_RX_vect)
   \                     handler_USART1_RX_vect:
    559          {
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   934A               ST      -Y, R20
   \   00000006   933A               ST      -Y, R19
   \   00000008   932A               ST      -Y, R18
   \   0000000A   931A               ST      -Y, R17
   \   0000000C   930A               ST      -Y, R16
   \   0000000E   B73F               IN      R19, 0x3F
   \   00000010   B74B               IN      R20, 0x3B
    560              uint8_t tail = uart_1_buffer.rx_buf_tail;
   \   00000012   9100....           LDS     R16, (uart_1_buffer + 23)
    561          
    562              /* Count of bytes received through UART 1 channel is incremented. */
    563              uart_1_buffer.rx_count++;
   \   00000016   9110....           LDS     R17, (uart_1_buffer + 25)
   \   0000001A   9513               INC     R17
   \   0000001C   9310....           STS     (uart_1_buffer + 25), R17
    564          
    565              uart_1_buffer.rx_buf[tail] = UDR1;
   \   00000020   9120....           LDS     R18, _A_UDR1
   \   00000024   E010               LDI     R17, 0
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   ....               SUBI    R30, LOW((-(uart_1_buffer) & 0xFFFF))
   \   0000002A   ....               SBCI    R31, (-(uart_1_buffer) & 0xFFFF) >> 8
   \   0000002C   8722               STD     Z+10, R18
    566          
    567              if ((UART_MAX_RX_BUF_LENGTH - 1) == uart_1_buffer.rx_buf_tail)
   \   0000002E   9110....           LDS     R17, (uart_1_buffer + 23)
   \   00000032   3019               CPI     R17, 9
   \   00000034   F421               BRNE    ??handler_USART1_RX_vect_0
    568              {
    569                   /* Revert back to beginning of buffer after reaching end of buffer. */
    570                  uart_1_buffer.rx_buf_tail = 0;
   \   00000036   E010               LDI     R17, 0
   \   00000038   9310....           STS     (uart_1_buffer + 23), R17
   \   0000003C   C005               RJMP    ??handler_USART1_RX_vect_1
    571              }
    572              else
    573              {
    574                  uart_1_buffer.rx_buf_tail++;
   \                     ??handler_USART1_RX_vect_0:
   \   0000003E   9110....           LDS     R17, (uart_1_buffer + 23)
   \   00000042   9513               INC     R17
   \   00000044   9310....           STS     (uart_1_buffer + 23), R17
    575              }
    576          }
   \                     ??handler_USART1_RX_vect_1:
   \   00000048   BF4B               OUT     0x3B, R20
   \   0000004A   BF3F               OUT     0x3F, R19
   \   0000004C   9109               LD      R16, Y+
   \   0000004E   9119               LD      R17, Y+
   \   00000050   9129               LD      R18, Y+
   \   00000052   9139               LD      R19, Y+
   \   00000054   9149               LD      R20, Y+
   \   00000056   91E9               LD      R30, Y+
   \   00000058   91F9               LD      R31, Y+
   \   0000005A   9518               RETI
   \   0000005C                      REQUIRE _A_UDR1
    577          
    578          
    579          
    580          /**
    581           * @brief ISR for UART 1 transmit interrupt
    582           *
    583           * This service routine is executed when a byte is transmitted successfully on
    584           * UART channel 1.
    585           */

   \                                 In  segment CODE, align 2, keep-with-next
    586          ISR(USART1_TX_vect)
   \                     handler_USART1_TX_vect:
    587          {
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   933A               ST      -Y, R19
   \   00000006   932A               ST      -Y, R18
   \   00000008   931A               ST      -Y, R17
   \   0000000A   930A               ST      -Y, R16
   \   0000000C   B72F               IN      R18, 0x3F
   \   0000000E   B73B               IN      R19, 0x3B
    588              if ((UART_MAX_TX_BUF_LENGTH - 1) == uart_1_buffer.tx_buf_head)
   \   00000010   9100....           LDS     R16, (uart_1_buffer + 20)
   \   00000014   3009               CPI     R16, 9
   \   00000016   F421               BRNE    ??handler_USART1_TX_vect_0
    589              {
    590                  /* Reached the end of buffer, revert back to beginning of buffer. */
    591                  uart_1_buffer.tx_buf_head = 0;
   \   00000018   E000               LDI     R16, 0
   \   0000001A   9300....           STS     (uart_1_buffer + 20), R16
   \   0000001E   C005               RJMP    ??handler_USART1_TX_vect_1
    592              }
    593              else
    594              {
    595                  /*
    596                   * Increment the index to point the next character to be
    597                   * transmitted.
    598                   */
    599                  uart_1_buffer.tx_buf_head++;
   \                     ??handler_USART1_TX_vect_0:
   \   00000020   9100....           LDS     R16, (uart_1_buffer + 20)
   \   00000024   9503               INC     R16
   \   00000026   9300....           STS     (uart_1_buffer + 20), R16
    600              }
    601          
    602              if (uart_1_buffer.tx_buf_head != uart_1_buffer.tx_buf_tail)
   \                     ??handler_USART1_TX_vect_1:
   \   0000002A   9100....           LDS     R16, (uart_1_buffer + 20)
   \   0000002E   9110....           LDS     R17, (uart_1_buffer + 21)
   \   00000032   1701               CP      R16, R17
   \   00000034   F051               BREQ    ??handler_USART1_TX_vect_2
    603              {
    604                  UDR1 = uart_1_buffer.tx_buf[uart_1_buffer.tx_buf_head];
   \   00000036   9100....           LDS     R16, (uart_1_buffer + 20)
   \   0000003A   E010               LDI     R17, 0
   \   0000003C   01F8               MOVW    R31:R30, R17:R16
   \   0000003E   ....               SUBI    R30, LOW((-(uart_1_buffer) & 0xFFFF))
   \   00000040   ....               SBCI    R31, (-(uart_1_buffer) & 0xFFFF) >> 8
   \   00000042   8100               LD      R16, Z
   \   00000044   9300....           STS     _A_UDR1, R16
   \   00000048   C003               RJMP    ??handler_USART1_TX_vect_3
    605              }
    606              else
    607              {
    608                  /* No more data for transmission */
    609                  uart_1_buffer.tx_count = 0;
   \                     ??handler_USART1_TX_vect_2:
   \   0000004A   E000               LDI     R16, 0
   \   0000004C   9300....           STS     (uart_1_buffer + 24), R16
    610              }
    611          }
   \                     ??handler_USART1_TX_vect_3:
   \   00000050   BF3B               OUT     0x3B, R19
   \   00000052   BF2F               OUT     0x3F, R18
   \   00000054   9109               LD      R16, Y+
   \   00000056   9119               LD      R17, Y+
   \   00000058   9129               LD      R18, Y+
   \   0000005A   9139               LD      R19, Y+
   \   0000005C   91E9               LD      R30, Y+
   \   0000005E   91F9               LD      R31, Y+
   \   00000060   9518               RETI
   \   00000062                      REQUIRE _A_UDR1

   \                                 In  segment INTVEC, offset 0x90, root
   \                     `??handler_USART1_RX_vect??INTVEC 144`:
   \   00000090   ........           JMP     handler_USART1_RX_vect

   \                                 In  segment INTVEC, offset 0x98, root
   \                     `??handler_USART1_TX_vect??INTVEC 152`:
   \   00000098   ........           JMP     handler_USART1_TX_vect
    612          #endif  /* UART1 */
    613          
    614          #endif  /* ((defined UART0) || (defined UART1)) */
    615          
    616          /* EOF */

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
       7      2  handler_USART1_RX_vect
       6      2  handler_USART1_TX_vect
       8      4  sio_uart_1_init
       0      2  sio_uart_1_rx
       0      2  sio_uart_1_tx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??handler_USART1_RX_vect??INTVEC 144
       4  ??handler_USART1_TX_vect??INTVEC 152
       2  _A_UBRR1
       1  _A_UCSR1A
       1  _A_UCSR1B
       1  _A_UCSR1C
       1  _A_UDR1
      92  handler_USART1_RX_vect
      98  handler_USART1_TX_vect
     108  sio_uart_1_init
     152  sio_uart_1_rx
     162  sio_uart_1_tx
      26  uart_1_buffer
       7  -- Other

 
   6 bytes in segment ABSOLUTE
 612 bytes in segment CODE
   7 bytes in segment INITTAB
   8 bytes in segment INTVEC
  26 bytes in segment NEAR_Z
 
 612 bytes of CODE memory (+ 15 bytes shared)
  26 bytes of DATA memory (+  6 bytes shared)

Errors: none
Warnings: none
