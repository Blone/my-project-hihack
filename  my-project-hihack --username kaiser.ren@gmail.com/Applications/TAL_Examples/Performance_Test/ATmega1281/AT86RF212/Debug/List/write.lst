###############################################################################
#                                                                             #
# IAR C/C++ Compiler V6.11.1.50453 for Atmel AVR        24/Nov/2012  12:23:00 #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\HiJack\Applications\Helper_Files\SIO_Support\IAR_Supp #
#                    ort\write.c                                              #
#    Command line =  D:\HiJack\Applications\Helper_Files\SIO_Support\IAR_Supp #
#                    ort\write.c --cpu=m1281 -ms -o                           #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\AT86RF212\Debug\Obj\ -D DEBUG=0 -D FFD -D        #
#                    HIGH_DATA_RATE_SUPPORT -D ENABLE_TFA -D SIO_HUB -D       #
#                    UART1 -D TAL_TYPE=AT86RF212 -D PAL_TYPE=ATMEGA1281 -D    #
#                    PAL_GENERIC_TYPE=AVR -D BOARD_TYPE=ATZB_900_MN2 -D       #
#                    HIGHEST_STACK_LAYER=PAL -lCN                             #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\AT86RF212\Debug\List\ --remarks -y               #
#                    --initializers_in_flash --no_cse --no_inline             #
#                    --no_code_motion --no_cross_call --no_clustering         #
#                    --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I         #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\Inc\ -I D:\HiJack\Applications\TAL_Examples\P #
#                    erformance_Test\ATmega1281\ -I                           #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\Helper_Files\SIO_Support\Inc\ -I        #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\Include\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\TAL\Inc\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\TAL\AT86RF212\Inc\ -I                #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\TFA\Inc\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\Inc\ -I                          #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\Generic\Inc\ -I              #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\ATMEGA1281\Inc\ -I           #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\ATMEGA1281\Boards\ -I        #
#                    D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\..\..\..\..\PAL\AVR\ATMEGA1281\Boards\ATZB_900_M #
#                    N2\ -I D:\HiJack\Applications\TAL_Examples\Performance_T #
#                    est\ATmega1281\..\..\..\..\Resources\Buffer_Management\I #
#                    nc\ -I D:\HiJack\Applications\TAL_Examples\Performance_T #
#                    est\ATmega1281\..\..\..\..\Resources\Queue_Management\In #
#                    c\ --eeprom_size 4096 --dlib --dlib_config "D:\Program   #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On                #
#    List file    =  D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\AT86RF212\Debug\List\write.lst                   #
#    Object file  =  D:\HiJack\Applications\TAL_Examples\Performance_Test\ATm #
#                    ega1281\AT86RF212\Debug\Obj\write.r90                    #
#                                                                             #
#                                                                             #
###############################################################################

D:\HiJack\Applications\Helper_Files\SIO_Support\IAR_Support\write.c
      1          /**
      2           * @file write.c
      3           *
      4           * @brief Implements the WRITE function used by standard library.
      5           *
      6           * This is a template implementation of the "__write" function used by
      7           * the standard library.  Replace it with a system-specific
      8           * implementation.
      9           *
     10           * The "__write" function should output "size" number of bytes from
     11           * "buffer" in some application-specific way. It should return the
     12           * number of characters written, or _LLIO_ERROR on failure.
     13           *
     14           * If "buffer" is zero then __write should perform flushing of
     15           * internal buffers, if any. In this case "handle" can be -1 to
     16           * indicate that all handles should be flushed.
     17           *
     18           * The template implementation below assumes that the application
     19           * provides the function "low_level_putchar". It should return the
     20           * character written, or -1 on failure.
     21           *
     22           * $Id: write.c 16779 2009-07-29 13:15:48Z sschneid $
     23           *
     24           * @author    Atmel Corporation: http://www.atmel.com
     25           * @author    Support email: avr@atmel.com
     26           */
     27          /*
     28           * Copyright (c) 2009, Atmel Corporation All rights reserved.
     29           *
     30           * Licensed under Atmel's Limited License Agreement --> EULA.txt
     31           */
     32          
     33          /* === Includes ============================================================ */
     34          
     35          #if ((defined __ICCAVR__) || (defined __ICCARM__))
     36          
     37          #include <yfuns.h>
     38          #include <stdint.h>
     39          #include "sio_handler.h"
     40          
     41          _STD_BEGIN
     42          
     43            #pragma module_name = "?__write"
     44          
     45          /* === Macros ============================================================== */
     46          
     47          
     48          /* === Globals ============================================================= */
     49          
     50          
     51          /* === Prototypes ========================================================== */
     52          
     53          
     54          /* === Implementation ====================================================== */
     55          

   \                                 In  segment CODE, align 2, keep-with-next
     56          int low_level_putchar(int x)
   \                     low_level_putchar:
     57          {
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   01C8               MOVW    R25:R24, R17:R16
     58              return _sio_putchar((char) x);
   \   00000006   2F08               MOV     R16, R24
   \   00000008   ........           CALL    _sio_putchar
   \   0000000C   9189               LD      R24, Y+
   \   0000000E   9199               LD      R25, Y+
   \   00000010   9508               RET
     59          }
     60          
     61          
     62          /*
     63           * If the __write implementation uses internal buffering, uncomment
     64           * the following line to ensure that we are called with "buffer" as 0
     65           * (i.e. flush) when the application terminates.
     66           */

   \                                 In  segment CODE, align 2, keep-with-next
     67          size_t __write(int handle, const unsigned char * buffer, size_t size)
   \                     __write:
     68          {
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004   0128               MOVW    R5:R4, R17:R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
   \   00000008   01DA               MOVW    R27:R26, R21:R20
     69              size_t nChars = 0;
   \   0000000A   2466               CLR     R6
   \   0000000C   2477               CLR     R7
     70          
     71              if (buffer == 0)
   \   0000000E   2F08               MOV     R16, R24
   \   00000010   2B09               OR      R16, R25
   \   00000012   F419               BRNE    ??__write_0
     72              {
     73                  /*
     74                   * This means that we should flush internal buffers.  Since we
     75                   * don't we just return. (Remember, "handle" == -1 means that all
     76                   * handles should be flushed.)
     77                   */
     78                  return 0;
   \   00000014   E000               LDI     R16, 0
   \   00000016   E010               LDI     R17, 0
   \   00000018   C021               RJMP    ??__write_1
     79              }
     80          
     81              /*
     82               * This template only writes to "standard out" and "standard err",
     83               * for all other file handles it returns failure.
     84               */
     85              if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
   \                     ??__write_0:
   \   0000001A   E001               LDI     R16, 1
   \   0000001C   1640               CP      R4, R16
   \   0000001E   E000               LDI     R16, 0
   \   00000020   0650               CPC     R5, R16
   \   00000022   F041               BREQ    ??__write_2
   \   00000024   E002               LDI     R16, 2
   \   00000026   1640               CP      R4, R16
   \   00000028   E000               LDI     R16, 0
   \   0000002A   0650               CPC     R5, R16
   \   0000002C   F019               BREQ    ??__write_2
     86              {
     87                  return _LLIO_ERROR;
   \   0000002E   EF0F               LDI     R16, 255
   \   00000030   EF1F               LDI     R17, 255
   \   00000032   C014               RJMP    ??__write_1
     88              }
     89          
     90              for (/* Empty */; size != 0; --size)
   \                     ??__write_2:
   \   00000034   2F0A               MOV     R16, R26
   \   00000036   2B0B               OR      R16, R27
   \   00000038   F081               BREQ    ??__write_3
     91              {
     92                  if (low_level_putchar(*buffer++) < 0)
   \   0000003A   01FC               MOVW    R31:R30, R25:R24
   \   0000003C   8100               LD      R16, Z
   \   0000003E   E010               LDI     R17, 0
   \   00000040   ....               RCALL   low_level_putchar
   \   00000042   9601               ADIW    R25:R24, 1
   \   00000044   2311               TST     R17
   \   00000046   F41A               BRPL    ??__write_4
     93                  {
     94                      return _LLIO_ERROR;
   \   00000048   EF0F               LDI     R16, 255
   \   0000004A   EF1F               LDI     R17, 255
   \   0000004C   C007               RJMP    ??__write_1
     95                  }
     96          
     97                  ++nChars;
   \                     ??__write_4:
   \   0000004E   E001               LDI     R16, 1
   \   00000050   0E60               ADD     R6, R16
   \   00000052   E000               LDI     R16, 0
   \   00000054   1E70               ADC     R7, R16
     98              }
   \   00000056   9711               SBIW    R27:R26, 1
   \   00000058   CFED               RJMP    ??__write_2
     99          
    100              return nChars;
   \                     ??__write_3:
   \   0000005A   0183               MOVW    R17:R16, R7:R6
   \                     ??__write_1:
   \   0000005C   E0E8               LDI     R30, 8
   \   0000005E   ........           JMP     ?EPILOGUE_B8_L09
    101          }
    102          
    103          _STD_END
    104          
    105          #endif  /* ((defined __ICCAVR__) || (defined __ICCARM__)) */
    106          
    107          /* EOF */

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
       8      2  __write
                   8 2 -> low_level_putchar
       2      2  low_level_putchar
                   2 2 -> _sio_putchar


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      98  __write
      18  low_level_putchar

 
 116 bytes in segment CODE
 
 116 bytes of CODE memory

Errors: none
Warnings: none
